\chapter{Implementation}

\section{Requirements}

\subsection{General information}
All the methods, which have been discussed in this paper, are a part of a library that can be used to solve multi-label classification problems in practise. The library was called \textit{MLCPACK}, which stands for \textit{Multi-Label Classification PACKage}. \textit{MLCPACK} was created for the purposes of the experiments, however one day it might be used by real applications. 

The \textit{API} was implemented in \textit{C++11} programming language and should be compiled by \textit{GCC ($>=$4.9)} in order to support all of new \textit{C++} features. The other compilers (\textit{Clang}, \textit{Visual C++ Compiler} etc.) have not been checked so far, so there is no warranty the build process succeeds in those cases.  The compilation process in managed by \textit{CMake} tool which is cross-platform and can be used in various operating systems \cite{CMake}. However, the library was tested only in \textit{Linux} environment (Debian 8.2). 

Besides using the standard \textit{C++} library, there are also two external libraries which must be installed in a system: 

\begin{itemize}
    \item Boost ($>=$1.55)
    \item Armadillo ($>=$6.100)
\end{itemize}
The first one contains useful modules which extends possibilities of the standard library (unittests, file system etc.), while \textit{Armadillo} is an advanced linear algebra library which is discussed in the next section.  


\subsection{Discussing linear algebra library used in project}

The efficency of the algorithms, which are presented in Chapter 2, is strongly dependent on implementations of linear algebra operations such as pseudoinverse, \textit{SVD} decomposition etc. After analysing available solutions, the \textit{API} provided by \textit{Armadillo} was chosen. \textit{Armadillo} is high-quality library dedicated for \textit{C++} developers. The main strength of it is a good balance between a speed and ease of use. In fact, its syntax is similar to \textit{Matlab} environment. The example of source code is presented in \Cref{app:arma}.

Usage of \textit{Armadillo} is simple, as it is shawn in \Cref{app:arma}. However, the most important issue is a real speed of matrix operations. According to the documentation, the \textit{API} is integrated with \textit{LAPACK} and \textit{BLAS} what means that effectiveness of matrix multiplication or its decompositions are dependent on these libraries - they are known as rather fast. There is also a possibility of linking \textit{OpenBLAS} instead of standard \textit{BLAS}. \textit{OpenBLAS} supports multithreading. The number of threads, involved in computation, can be easily controlled by setting specific environment variables, i.e. \textit{OPENBLAS\_NUM\_THREADS} \cite{Blas}. In the implementation of \textit{MLCPACK}, \textit{OpenBLAS} library is used.    

\begin{figure}[h]
\centering
\caption{Multiplication matrix performance}
\label{fig:mulperf}
\begin{tikzpicture}
    \begin{axis}[legend pos=north east,
        xlabel={size of matrix},
        ylabel={time [s]},
        xmin=0,
        xmax=10500,
        ymin=0,
        ymax=200000,
        ymode=log]
        \addplot table [x=size, y=arma, col sep=semicolon] {figures/mul_test.csv};
        \addlegendentry{Armadillo}
        \addplot table [x=size, y=numpy, col sep=semicolon] {figures/mul_test.csv};
        \addlegendentry{NumPy}
    \end{axis}
\end{tikzpicture}
\end{figure}

\begin{figure}
\centering
\caption{SVD decomposition of matrix performance}
\label{fig:svdperf}
\begin{tikzpicture}
    \begin{axis}[legend pos=north east,
        xlabel={size of matrix},
        ylabel={time [s]},
        xmin=0,
        xmax=4500,
        ymin=0,
        ymax=650]
        \addplot table [x=size, y=arma, col sep=semicolon] {figures/svd_test.csv};
        \addlegendentry{Armadillo}
        \addplot table [x=size, y=numpy, col sep=semicolon] {figures/svd_test.csv};
        \addlegendentry{NumPy}

    \end{axis}
\end{tikzpicture}
\end{figure}


\Cref{fig:mulperf} and \Cref{fig:svdperf} show the speed of basic matrix operations performed by \textit{Armadillo} and \textit{NumPy} which is an analogous linear algebra module for \textit{Python} programming language. As we see \textit{Armadillo} is definitely faster than \textit{NumPy} for matrix multiplication and \textit{SVD} decomposition as well.   
The experiment was run on the machine which has Intel Core i3-350M 2.26 GHz processor and 4096 MB of RAM. In case of \textit{Armadillo}, the compilation of program was optimized (third level of optimization) and \textit{OpenBLAS} was used instead of standard \textit{BLAS} library. \textit{NumPy} (1.8.2) was tested in \textit{Python3.4} environment (standard installation from \textit{Debian} repository). Diffrences in time-consumption justify the choice of \textit{Armadillo} and \text{C++11} programming language, however \textit{NumPy} also uses \textit{BLAS} what means that it is possible to install \textit{NumPy} with \textit{OpenBLAS} support.

\section{Structure of library}

\textit{Mlcpack} consists of the two main modules:
\begin{itemize}
    \item \textit{Algorithms}
    \item \textit{Utils}
\end{itemize}

\subsection{Description of \textit{Algorithms} module}

The \textit{Algorithms} module contains all implementations of the algorithms discussed in this paper. Its building is based on \textit{Strategy} design pattern which is typical for specific family of algorithms. A client is allowed to simply rotate various methods - in other words, algorithms are replaced regardless of clients which use them. The structure of this module is shown in \Cref{fig:alg_sh}. 

The base class for the algorithm implementations is \textit{IStrategy}. The class contains two pure virtual methods: \textit{learn} and \textit{classify} which must be implemented. The second function takes an object of \textit{Intance} type as an argument which certainly wraps a particular instance and returns binary vector of labels. The constructor of \textit{IStrategy} takes an only one argument of \textit{Instances} type which represents a training set. Let us notice that \textit{LinearRegression} class, which inherits directly from \textit{IStrategy}, is a base class for the rest of the methods. The regressor is an important component for all the approaches, therefore this relation is represented by an inheritance. In \textit{LinearRegression} there are also two additional methods: \textit{save} and \textit{load} which take one argument of \textit{string} type. These functions are responsible for a serialization of a trained classifier. The idea is to store such a classifier on hard drive and load it into memory if it is needed. It certainly allows to save time, especially if we take into account massive training sets. In contrast to \textit{IStrategy} interface, \textit{LinearRegression} class and its deriving classes have more complex constructors. The linear regressor class constructor (and its deriving classes constructors as well) takes an additional argument which is a regularization parameter. \textit{CPLST}, \textit{LRWithPCA} etc. constructors need also a reduction degree parameter. The 'learning flow' is presented in \Cref{app:learning}.

\textit{Algorithms} module also contains class (\textit{Evaluation}) which is used to evaluate particular methods. It allows to measure quality of classification by parameters, such as \textit{Micro-}, \textit{Instance-} and \textit{Macro-average of Precision}, \textit{Recall} and \textit{F-score}. It also calculates \textit{Hamming loss} metric. The \textit{API} is simple, as it is shown in \Cref{fig:alg_sh}. To construct an evaluator, we have to pass two arguments: a training set and a number of folds used for cross-validation purpose. In order to start the whole process we certainly invoke \textit{evaluate} method which takes a reference to \textit{IStrategy} object. The rest of the functions allow to get a specific evaluation metric. The 'evaluating flow' is presented in \Cref{app:evaluating}.

\begin{figure}
\centering
\caption{UML diagram of Algorithms module}
\label{fig:alg_sh}
\includegraphics[scale=0.5]{figures/mlcpack.png}
\end{figure}

\subsection{Description of \textit{Utils} module}

The schema of \textit{Utils} module is shown in \Cref{fig:utils_sh}. The module contains classes which process and provide training data for \textit{IStrategy} objects. The \textit{API} was designed to support \textit{ARFF} data format (the example of data written in this format is presented in \Cref{app:arff}), however there is a possibility to add different types of parsers. Each parser must inherit from \textit{IParser} interface and implement two methods: \textit{parse} and \textit{getInstances}. The first method is certainly responsible for processing an input file, while the second method wraps parsed raw data by \textit{Instance} and \textit{Instances} objects. Let us notice that \textit{ArffParser} objects take an additional argument in its constructor. This second argument is a path to a file containing extra information about attributes which are, in fact, labels.

\textit{Instance} and \textit{Instances} classes, which have already been mentioned, are used to simplify performing various operations on data. An object of \textit{Instance} type wraps a single instance in a data set. As we see in \Cref{fig:utils_sh}, this class contains methods which allow to write (\textit{setAttributeValue}) or read (\textit{getValueOfAttr}) value of a specific attribute of an instance. An object of \textit{Instances} type is a collection of \textit{Instance} objects. \textit{getAttributeMat} and \textit{getTargetsMat} methods of this class are used to generate a matrix of features and a matrix of labels as objects provided by \textit{Armadillo} library. There is also \textit{shuffle} method which changes randomly an order of instances.  

\begin{figure}
\centering
\caption{UML diagram of Utils module}
\label{fig:utils_sh}
\includegraphics[scale=0.5]{figures/Utils.png}
\end{figure}

